{"data":{"site":{"siteMetadata":{"title":"Dulldave","author":"David Dyke"}},"markdownRemark":{"id":"76bbdd97-357f-5442-b199-5ee85f10ece9","excerpt":"I’ve worked in Go on and off for a little while now and have a handful of projects in production. I thought I’d use this as an opportunity to write down what I…","html":"<p>I’ve worked in Go on and off for a little while now and have a handful of projects in production. I thought I’d use this as an opportunity to write down what I’ve found works quite well and what I’ve found is simple enough for any developer to pick up.</p>\n<p>My projects tend to follow the <a href=\"https://github.com/golang-standards/project-layout\">Standard Go Project Layout</a>. But with a few modifications, like removing the extra nested directories under the <code class=\"language-text\">internal/</code> directory (<code class=\"language-text\">internal/app/</code> and <code class=\"language-text\">internal/pkg/</code>). I tend to find that just putting my packages under <code class=\"language-text\">internal/</code> works fine. But other than that my projects follow the standard layout pretty close.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app/\n└── internal/\n    ├── someservice/\n    └── auth/</code></pre></div>\n<p>All packages under internal are grouped by commonality. I prefer keeping code that’s related close together and I’m not a huge fan of splitting by it’s function e.g. all handlers under a handlers package. So, for example, if my service requires a user to login or register, I will group that functionality under an auth package, which would contain all of the grouped logic to satisfy that requirement.</p>\n<p>Within each package under <code class=\"language-text\">internal/</code> I usually have 3 main files:</p>\n<ul>\n<li><strong>handlers.go</strong>, this contains all HTTP handlers needed for this package as well as handles anything specific to the request and response, any other file within this package doesn’t have knowledge of where the data comes or goes to.</li>\n<li><strong>store.go</strong>, this is essentially a repository to access some sort of datastore.</li>\n<li><strong>service.go</strong>, which contains the business logic for the package. For example, if we had an auth package, and part of that package was for registering a user, service.go would have a method that could validate that the user doesn’t already exist in the database through the provided store, it would then hash the inputted password using another injected service, then it would pass the final user details to another store method for adding a user, and finally it would trigger an email to notify that user.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app/\n└── internal/\n    ├── someservice/\n    └── auth/\n        ├── handlers.go\n        ├── handlers_test.go\n        ├── store.go\n        ├── store_test.go\n        ├── service.go\n        └── service_test.go</code></pre></div>\n<p>I’m not strict on the file names, I usually just group related functionality under each file and name them appropriately. The above just seem to be the common ones I use.</p>\n<p>Each component under the auth package usually has an associated interface, this allows us to inject those components into where they need to go which makes testing a whole lot easier.</p>\n<p>So <strong>store.go</strong> might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> auth\n\n<span class=\"token keyword\">type</span> Store <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">GetUserByID</span><span class=\"token punctuation\">(</span>id <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> User\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> store <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Store <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>store<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>store<span class=\"token punctuation\">)</span> <span class=\"token function\">GetUserByID</span><span class=\"token punctuation\">(</span>id <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> User <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> User<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then in service.go, we can easily inject store:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> auth\n\n<span class=\"token keyword\">type</span> Service <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span>id <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> User\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> service <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  store Store\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewService</span><span class=\"token punctuation\">(</span>store Store<span class=\"token punctuation\">)</span> Service <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>service<span class=\"token punctuation\">{</span> store <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>service<span class=\"token punctuation\">)</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span>id <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> User <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">GetUserByID</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And in handler.go we can finally use everything together:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> auth\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Handler</span><span class=\"token punctuation\">(</span>svc Service<span class=\"token punctuation\">)</span> http<span class=\"token punctuation\">.</span>HandlerFunc <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>w http<span class=\"token punctuation\">.</span>ResponseWriter<span class=\"token punctuation\">,</span> r \\<span class=\"token operator\">*</span>http<span class=\"token punctuation\">.</span>Request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    svc<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some-user-id\"</span><span class=\"token punctuation\">)</span>\n\n    w<span class=\"token punctuation\">.</span><span class=\"token function\">WriteHeader</span><span class=\"token punctuation\">(</span>http<span class=\"token punctuation\">.</span>StatusOK<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>When it comes to testing we can provide mock instances of each injected component where needed.</p>\n<p>Everything is then glued together in <strong>main.go</strong>, which is located under <code class=\"language-text\">cmd/&lt;appname&gt;/main.go</code>. I tend to find that <strong>main.go</strong> can get quite large, but I prefer seeing everything being initialised and passed to it’s required destination in one place.</p>\n<p>With the above examples, initialising the auth package might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token string\">\"log\"</span>\n\n  <span class=\"token string\">\"github.com/gorilla/mux\"</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// Create router</span>\n  router <span class=\"token operator\">:=</span> mux<span class=\"token punctuation\">.</span><span class=\"token function\">NewRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// Create Postgres client</span>\n  postgres <span class=\"token operator\">:=</span> postgres<span class=\"token punctuation\">.</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// Auth handlers</span>\n  authStore <span class=\"token operator\">:=</span> auth<span class=\"token punctuation\">.</span><span class=\"token function\">NewStore</span><span class=\"token punctuation\">(</span>postgres<span class=\"token punctuation\">)</span>\n  authService <span class=\"token operator\">:=</span> auth<span class=\"token punctuation\">.</span><span class=\"token function\">NewService</span><span class=\"token punctuation\">(</span>authStore<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// Routes</span>\n  router<span class=\"token punctuation\">.</span><span class=\"token function\">Handle</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user\"</span><span class=\"token punctuation\">,</span> auth<span class=\"token punctuation\">.</span><span class=\"token function\">Handler</span><span class=\"token punctuation\">(</span>authService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Methods</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">ListenAndServe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":8000\"</span><span class=\"token punctuation\">,</span> router<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    log<span class=\"token punctuation\">.</span><span class=\"token function\">Fatal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error starting HTTP server\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>One problem I’ve noticed with this setup is circular dependency issues that crop every so often. Which can be a pain. I’m currently experimenting with another setup by Ben Johnson, which will hopefully minimise this: <a href=\"https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1\">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a></p>","frontmatter":{"title":"How I like to Structure and Build Go Services","date":"March 16, 2019","description":null}}},"pageContext":{"slug":"/how-i-like-to-structure-and-build-go-services/","previous":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"}},"next":null}}