{"data":{"site":{"siteMetadata":{"title":"Dulldave","author":"David Dyke"}},"markdownRemark":{"id":"f39e040a-e2af-5285-819e-f7a2fd0a1b36","excerpt":"I came across an incident recently where data was going to a service via SQS, upon hitting that service it would then talk to a bunch of other services toâ€¦","html":"<p>I came across an incident recently where data was going to a service via SQS, upon hitting that service it would then talk to a bunch of other services to gather more data for the request. At the same time, an attack had taken down the connection to those other services which was causing our requests to fail and move to our dead letter queue.</p>\n<p>Now, these requests werenâ€™t broken, they were just victim to a one-off transient error. The data within the request was perfectly valid. But, at this time, the dead letter queue was used more for logging the very occasional permanent error that had occurred and being able to replay those items was never needed.</p>\n<p>Because of that incident, I wanted to build something that could be turned on at a moments notice and be used to replay messages in the dead letter queue, albeit temporarily.</p>\n<p>At first, I was toying with the idea of creating a generic CLI tool to run from my machine. It would simply poll the DLQ and replay those items on to the main queue. But I didnâ€™t like the idea of having a random script on my laptop that only I could run to solve a fundamental issue that was likely to happen again.</p>\n<p>What we needed was a CLI tool like above, but we need it to be in a generic location for anyone to configure and run.</p>\n<p>Lambda seemed to be a good fit for this. With a Lambda we can have all of the code stored in one place. Preconfigured, with the triggers disabled. Then only when we need to, enable them to start replaying messages.</p>\n<p>Plus Lambdaâ€™s are simple, we only need to specify a queue to trigger the Lambda against and a queue to replay those items too. So when we start getting notified via our CloudWatch alarms that the DLQ is filling up we can diagnose the issue and at the right time replay those items.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/fa8c3/enabled-trigger.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 12.649006622516556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAASklEQVQI153MOw7AIAwDUO5/WJZC/olLW4mdDs+SB7uFG1R1kx+enZm9Wh+8S0Sgqo6sgEaiX4Q5J9ogBouA+DvOzGOxDtV87R033gTsG0/IePoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"AWS Lambda console showing an enabled trigger\"\n        title=\"\"\n        src=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/6255c/enabled-trigger.png\"\n        srcset=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/375dc/enabled-trigger.png 148w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/6b157/enabled-trigger.png 295w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/6255c/enabled-trigger.png 590w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/dcf9c/enabled-trigger.png 885w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/43c8a/enabled-trigger.png 1180w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/dc8c4/enabled-trigger.png 1770w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/fa8c3/enabled-trigger.png 3020w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>The code itself is very simple. When the Lambda is triggered, it loops over the records that come in and simply forwards that message onto the output queue defined in an environment variable. Which then means the services listening to the output queue can start reprocessing the messages that had failed. ðŸŽ‰ðŸŽ‰ðŸŽ‰</p>\n<p>The full source code can be found here: <a href=\"https://github.com/dulldave/aws-sqs-dead-letter-replay-lambda\">dulldave/aws-sqs-dead-letter-replay-lambda</a></p>","frontmatter":{"title":"AWS SQS Dead Letter Replay Lambda","date":"March 17, 2019","description":"Ever needed to replay items in your dead letter queue?"}}},"pageContext":{"slug":"/aws-sqs-dead-letter-replay-lambda/","previous":{"fields":{"slug":"/how-i-like-to-structure-and-build-go-services/"},"frontmatter":{"title":"How I like to Structure and Build GoÂ Services"}},"next":null}}