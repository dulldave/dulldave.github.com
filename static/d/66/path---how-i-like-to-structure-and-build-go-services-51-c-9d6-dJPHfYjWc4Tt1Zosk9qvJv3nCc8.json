{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"76bbdd97-357f-5442-b199-5ee85f10ece9","excerpt":"I’ve worked in Go on and off for a little while now and have a handful of projects in production. I thought I’d use this as an opportunity to write down what I…","html":"<p>I’ve worked in Go on and off for a little while now and have a handful of projects in production. I thought I’d use this as an opportunity to write down what I’ve found works quite well and what I’ve found is simple enough for any developer to pick up.</p>\n<p>My projects tend to follow the Standard Go Project Layout. But with a few modifications. I’m not a fan of the extra nested directories under the internal/ directory (internal/app and internal/pkg). I tend to find that just putting my packages under internal/ works fine. But other than that my projects follow the standard layout pretty close.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app/\n└── internal/\n    ├── someservice/\n    └── auth/</code></pre></div>\n<p>All packages under internal are grouped by commonality. I prefer keeping code that’s related close together and I’m not a huge fan of splitting by it’s function e.g. all handlers under a handlers package. So, for example, if my service requires a user to login or register, I will group that functionality under an auth package, which would contain all of the grouped logic to satisfy that requirement. </p>\n<p>Within each package I usually have 3 main files:</p>\n<ul>\n<li><strong>handlers.go</strong>, this contains all HTTP handlers needed for this package as well as handles anything specific to the request and response, any other file within this package doesn’t have knowledge of where the data comes or goes to.</li>\n<li><strong>store.go</strong>, this is essentially a repository to access some sort of datastore.</li>\n<li><strong>service.go</strong>, which contains the business logic for the package. For example, if we had an auth package, and part of that package was for registering a user, service.go would have a method that could validate that the user doesn’t already exist in the database through the provided store, it would then hash the inputted password using another injected service, then it would pass the final user details to another store method for adding a user, and finally it would trigger an email to notify that user.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app/\n└── internal/\n    ├── someservice/\n    └── auth/\n        ├── handlers.go\n        ├── store.go\n        └── service.go</code></pre></div>\n<p>I’m not strict on the file names, I usually just group related functionality under each file and name them appropriately. The above just seem to be the common ones I use.</p>\n<p>Each component under the auth package usually has an associated interface, this allows us to inject those components into where they need to go which makes testing a whole lot easier.</p>\n<p>So store.go might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package auth\n\ntype Store interface {\n  GetUserByID(id string) User\n}\n\ntype store struct {}\n\nfunc NewStore() Store {\n  return &amp;store{}\n}\n\nfunc (s *store) GetUserByID(id string) User {\n  return User{}\n}</code></pre></div>\n<p>Then in service.go, we can easily inject store:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package auth\n\ntype Service interface {\n  Get(id string) User\n}\n\ntype service struct {\n  store Store\n}\n\nfunc NewService(store Store) Service {\n  return &amp;service{ store }\n}\n\nfunc (s *service) Get(id string) User {\n  return s.store.GetUserByID(id)\n}</code></pre></div>\n<p>And in handler.go we can finally use everything together:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package auth\n\nfunc Handler(svc Service) http.HandlerFunc {\n  return func(w http.ResponseWriter, r \\*http.Request) {\n    svc.Get(&quot;some-user-id&quot;)\n    w.WriteHeader(http.StatusOK)\n  }\n}</code></pre></div>\n<p>When it comes to testing we can provide mock instances of each injected component where needed.</p>\n<p>Everything is then glued together in the main.go file, which is located under cmd/<appname>/main.go. I tend to find that the main.go file can get quite large, but I prefer seeing everything being initialised and passed to it’s required destination in one place.\nWith the above examples, initialising the auth package might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package main\n\nimport (\n  &quot;github.com/gorilla/mux&quot;\n  ...\n)\n\nfunc main() {\n\n\t// Create router\n\trouter := mux.NewRouter()\n\n\t// Creates DynamoDB client\n\tpostgres := postgres.New()\n\n\t// Auth handlers\n\tauthStore := auth.NewStore(postgres)\n\tauthService := auth.NewService(authStore)\n\n\t// Routes\n\trouter.Handle(&quot;/user&quot;, auth.Handler(authService)).Methods(&quot;GET&quot;)\n\n\tlogger.Logger.Info(&quot;Starting HTTP server&quot;, zap.Int(&quot;binding&quot;, config.Server.Port))\n\tif err := http.ListenAndServe(fmt.Sprintf(&quot;:%d&quot;, config.Server.Port), router); err != nil {\n\t\tlogger.Logger.Fatal(&quot;Error starting HTTP server&quot;, zap.Error(err))\n\t}\n}</code></pre></div>\n<p>One problem I’ve noticed with this setup is circular dependency issues that crop every so often. Which can be a pain. I’m currently experimenting with another setup by Ben Johnson, which will hopefully minimise this: <a href=\"https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1\">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a></p>","frontmatter":{"title":"How I like to Structure and Build Go Services","date":"March 16, 2019","description":null}}},"pageContext":{"slug":"/how-i-like-to-structure-and-build-go-services/","previous":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"}},"next":null}}