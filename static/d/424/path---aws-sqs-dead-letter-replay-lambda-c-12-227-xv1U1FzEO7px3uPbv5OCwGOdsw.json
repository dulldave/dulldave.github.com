{"data":{"site":{"siteMetadata":{"title":"Dulldave","author":"David Dyke"}},"markdownRemark":{"id":"f39e040a-e2af-5285-819e-f7a2fd0a1b36","excerpt":"I came across an incident recently where data was going to a service via SQS, upon hitting that service it would then talk to a bunch of other services toâ€¦","html":"<p>I came across an incident recently where data was going to a service via SQS, upon hitting that service it would then talk to a bunch of other services to gather more data for the request. At the same time, an attack had taken down the connection to those other services which was causing our requests to fail and build upon a dead letter queue. Now, these requests werenâ€™t broken per se, they were just victim to a one-off transient error. The data within the request was perfectly valid, however, the dead letter queue was used more for logging the very occasional permanent error that had occurred and being able to replay those items was never needed.</p>\n<p>Because of that incident, I wanted to build something that could be turned on at a moments notice and be used to replay items in the dead letter queue, albeit temporarily.</p>\n<p>Lambda seemed to be a good fit for this. We could specify a queue to trigger the Lambda against and a queue to replay those items too. Which would mean if we got notified via our CloudWatch alarms that the DLQ was filling up we could diagnose the issue and at the right time consume those items in the DLQ.</p>\n<p>The other benefit of using a Lambda is that we can have all of the code sitting, with the triggers disabled, and only when we need to enable them to start the process.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/fa8c3/enabled-trigger.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 12.649006622516556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAASklEQVQI153MOw7AIAwDUO5/WJZC/olLW4mdDs+SB7uFG1R1kx+enZm9Wh+8S0Sgqo6sgEaiX4Q5J9ogBouA+DvOzGOxDtV87R033gTsG0/IePoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"AWS Lambda console showing an enabled trigger\"\n        title=\"\"\n        src=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/6255c/enabled-trigger.png\"\n        srcset=\"/static/b9666b3d1b2fa9bb1d10b8c19597c991/375dc/enabled-trigger.png 148w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/6b157/enabled-trigger.png 295w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/6255c/enabled-trigger.png 590w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/dcf9c/enabled-trigger.png 885w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/43c8a/enabled-trigger.png 1180w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/dc8c4/enabled-trigger.png 1770w,\n/static/b9666b3d1b2fa9bb1d10b8c19597c991/fa8c3/enabled-trigger.png 3020w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>The code itself is very simple. When the Lambda is triggered via SQS, it loops over the records that come in and simply forwards that message onto the output queue defined in the environment variables for the Lambda. Which then means the services listening to the output queue can start reprocessing the messages that had failed. ðŸŽ‰ðŸŽ‰ðŸŽ‰</p>\n<p>The full source code can be found here: <a href=\"https://github.com/dulldave/aws-sqs-dead-letter-replay-lambda\">dulldave/aws-sqs-dead-letter-replay-lambda</a></p>","frontmatter":{"title":"AWS SQS Dead Letter Replay Lambda","date":"March 17, 2019","description":"Ever needed to replay items in your dead letter queue?"}}},"pageContext":{"slug":"/aws-sqs-dead-letter-replay-lambda/","previous":{"fields":{"slug":"/how-i-like-to-structure-and-build-go-services/"},"frontmatter":{"title":"How I like to Structure and Build GoÂ Services"}},"next":null}}